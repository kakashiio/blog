{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"关于我","text":"Kakashi我是一名全栈游戏开发人员.目前从事游戏行业已经10年.当过游戏服务器主程序,游戏客户端主程序,目前在北京昆仑万维科技股份有限公司担任技术总监. 个人技能 技能 详细 服务器 Java、 Netty、 MySQL 客户端 Unity3D、 C#、Shader 愿景设计、开发、发布自己的游戏! GithubKakashi’s github","link":"/about/index.html"}],"posts":[{"title":"Unity-IOC","text":"问题想象一下,当你在实现一个UI管理器UIManager时,当在UIManager中需要加载UI资源时,你是通过何种方式加载资源的. 一般开发诸如AssetManager、TimeManager、EventManager等管理器(Manager)时.喜欢采用静态方法或单例.这样做是为了使得项目能方便地引用这些管理器. 常见的实现代码: 1234567891011121314public class UIManager{ public void Create&lt;T&gt;(Action&lt;T&gt; onCreate) where T : IUI { string assetPath = _GetAssetPath&lt;T&gt;(); AssetManager.Instantiate&lt;GameObject&gt;((go)=&gt;{ var t = new T(); t.Init(go); onCreate?.Invoke(t); }); }} 或 123456789101112public class UIManager{ public void Create&lt;T&gt;(Action&lt;T&gt; onCreate) where T : IUI { string assetPath = _GetAssetPath&lt;T&gt;(); Singleton&lt;AssetManager&gt;.Instance.Instantiate&lt;GameObject&gt;((go)=&gt;{ var t = new T(); t.Init(go); onCreate?.Invoke(t); }); }} 虽然静态方法或单例都能实现想要的效果,但或多或少会带来负面的效果.比如耦合严重,难以测试等等.因此本文引入一种已经很成熟的设计思路IoC,一步步实现一个简单的IoC容器,并且将IoC应用到实际中.大家也可以对比感受引入IoC前后代码发生的变化. IoC简述IoC(Inversion of Control,控制反转)通常也被称为DI(Dependency Injection,依赖注入).他是将传统对象依赖从内部指定改为外部决定的过程.比如上面的UIManager中内部指定了使用AssetManager.当使用IoC设计时,代码会修改为: 1234567891011121314151617181920public class UIManager{ private IAssetManager _AssetManager; public UIManager(IAssetManager assetManager) { _AssetManager = assetManager; } public void Create&lt;T&gt;(Action&lt;T&gt; onCreate) where T : IUI { string assetPath = _GetAssetPath&lt;T&gt;(); _AssetManager.Instantiate&lt;GameObject&gt;((go)=&gt;{ var t = new T(); t.Init(go); onCreate?.Invoke(t); }); }} 这是引入IoC最简单的例子,即把内部采用哪个IAssetManager实现的权力转移给外部,因此称为IoC(Inversion of Control,控制反转),由于UIManager依赖了IAssetManager而且将其实现通过外部构造传入,因此也称DI(Dependency Injection,依赖注入). 但是这样的代码明显不够方便,因为需要自己在构造时传入IAssetManager,如果只是UIManager需要传入IAssetManager实例还好,实际上可以预见的是SceneManager、UnitManager、EffectManager等类可能都需要IAssetManager,那么最终可能会有类似这样的代码: 123456789101112public class Main{ public void Init() { var assetManager = new AssetManager(); var uiManager = new UIManager(assetManager); var sceneManager = new SceneManager(assetManager); var unitManager = new UnitManager(assetManager); var effectManager = new EffectManager(assetManager); // ... }} 这样的代码重复、而且没有意义、不同的人反复在这里添加自己的代码也容易引发冲突和错误.我们应该编写一个更智能的IoC框架来帮助我们完成这些事情. 编写IoC框架添加依赖由于我们需要大量使用反射完成一些工作,因此通过PackageManager依赖我之前开源的用于反射的Packagehttps://github.com/kakashiio/Unity-Reflection 打开Unity的PackageManager并点击左上角的“+”按钮,选择&quot;Add package from git URL...&quot;并填入该地址https://github.com/kakashiio/Unity-Reflection.git#1.0.0 IoC容器定义IoC容器接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public interface IIOCContainer{ /// &lt;summary&gt; /// 实例化`type`类型的对象并注入其所有字段和属性 /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; object InstanceAndInject(Type type); /// &lt;summary&gt; /// 实例化类型为`T`的对象并注入其所有字段和属性 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; T InstanceAndInject&lt;T&gt;(); /// &lt;summary&gt; /// 为一个已存在的对象`obj`注入其所有字段和属性 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;recursive&quot;&gt; /// 如果recursive == true, 那么instance的字段也会被递归注入 /// &lt;/param&gt; void Inject(object obj, bool recursive = false); /// &lt;summary&gt; /// 查找`type`类型或`type`类型子类的对象. /// 如果指定了别名`alias`,那么需要满足别名条件 /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;alias&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; object FindObjectOfType(Type type, string alias = null); /// &lt;summary&gt; /// 查找`T`类型或`T`类型子类的对象. /// 如果指定了别名`alias`,那么需要满足别名条件 /// &lt;/summary&gt; /// &lt;param name=&quot;alias&quot;&gt;&lt;/param&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; T FindObjectOfType&lt;T&gt;(string alias = null) where T : class; /// &lt;summary&gt; /// 查找所有`type`类型或`type`类型子类的对象. /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; List&lt;object&gt; FindObjectsOfType(Type type); /// &lt;summary&gt; /// 查找所有`T`类型或`T`类型子类的对象. /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; List&lt;T&gt; FindObjectsOfType&lt;T&gt;() where T : class; /// &lt;summary&gt; /// 返回所有对象. /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; List&lt;object&gt; GetAllObjects(); /// &lt;summary&gt; /// 返回容器中所有方法上带有Attribute为`A`的方法. /// &lt;/summary&gt; /// &lt;typeparam name=&quot;A&quot;&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; List&lt;BeanMethods&gt; FindMethods&lt;A&gt;() where A : Attribute; /// &lt;summary&gt; /// 返回容器中所有方法上带有Attribute为`attribute`的方法. /// &lt;/summary&gt; /// &lt;param name=&quot;attribute&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; List&lt;BeanMethods&gt; FindMethods(Type attribute); /// &lt;summary&gt; /// 返回`obj`中带有Attribute为`attribute`的方法. /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;attribute&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;beanMethodList&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; BeanMethods FindMethods(Object obj, Type attribute);} IIOCContainer接口主要定义了一个IOC容器对外提供的服务.比如外部可以通过GetAllObjects方法获取到该容器管理的所有对象、也可以通过FindObjectOfType查找某个类型在容器中创建的实例、或者通过InstanceAndInject创建一个指定类型的对象,InstanceAndInject方法与new创建对象不同在于InstanceAndInject创建的对象会被容器管理,同时会自动按设计的约定注入字段. 这里每个方法都写了比较详细的注释.如果目前大家还不是很清楚,主要可能是对于IoC还不太熟悉,这关系不大.后面会通过实际使用的例子回过来深入介绍细节.接下来先把该接口的实现和另外几个比较重要的类的源码给出来,目前大家只要先大概浏览一下即可. 实现IoC容器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206public class IOCContainer : IIOCContainer{ private ITypeContainer _TypeContainer; private List&lt;object&gt; _Instances = new List&lt;object&gt;(); private HashSet&lt;object&gt; _InjectedObj = new HashSet&lt;object&gt;(); private Dictionary&lt;Type, object&gt; _FindCache = new Dictionary&lt;Type, object&gt;(); private Dictionary&lt;Type, Dictionary&lt;string, object&gt;&gt; _FindCacheWithQualifier = new Dictionary&lt;Type, Dictionary&lt;string, object&gt;&gt;(); public IOCContainer(ITypeContainer typeContainer) { _TypeContainer = typeContainer; var inheritedFromIOCComponent = Reflections.GetTypes(_TypeContainer, typeof(IOCComponent)); var typesWithIOCComponent = Reflections.GetTypesWithAttributes(_TypeContainer, inheritedFromIOCComponent); foreach (var type in typesWithIOCComponent) { _Instances.Add(_Instance(type)); } // Inject all type's field or property foreach (var instance in _Instances) { Inject(instance); } } public object InstanceAndInject(Type type) { var instance = _Instance(type); Inject(instance); return instance; } public T InstanceAndInject&lt;T&gt;() { return (T) InstanceAndInject(typeof(T)); } public void Inject(object obj, bool recursive = false) { if (obj == null) { return; } if (obj.GetType().IsPrimitive) { return; } if (recursive) { if (_InjectedObj.Contains(obj)) { return; } _InjectedObj.Add(obj); } var propertiesOrFields = Reflections.GetPropertiesAndFields&lt;Autowired&gt;(obj); foreach (var propertyOrField in propertiesOrFields) { var qualifier = propertyOrField.GetCustomAttribute&lt;Qualifier&gt;(); var fieldValue = FindObjectOfType(propertyOrField.GetFieldOrPropertyType(), qualifier != null ? qualifier.Name : null); propertyOrField.SetValue(obj, fieldValue); if (recursive) { Inject(fieldValue, true); } } } public object FindObjectOfType(Type type, string alias = null) { if (string.IsNullOrEmpty(alias)) { if (_FindCache.ContainsKey(type)) { return _FindCache[type]; } foreach (object instance in _Instances) { if(type.IsAssignableFrom(instance.GetType())) { _FindCache.Add(type, instance); return instance; } } } else { if (_FindCacheWithQualifier.ContainsKey(type)) { var qualifier2Instance = _FindCacheWithQualifier[type]; if (qualifier2Instance.ContainsKey(alias)) { return qualifier2Instance[alias]; } } foreach (object instance in _Instances) { var objType = instance.GetType(); if(type.IsAssignableFrom(objType)) { var qualifierAttr = objType.GetCustomAttribute(typeof(Qualifier)) as Qualifier; if (qualifierAttr != null &amp;&amp; string.Equals(qualifierAttr.Name, alias)) { Dictionary&lt;string, object&gt; qualifier2Instance = null; if (_FindCacheWithQualifier.ContainsKey(type)) { qualifier2Instance = _FindCacheWithQualifier[type]; } else { qualifier2Instance = new Dictionary&lt;string, object&gt;(); _FindCacheWithQualifier.Add(type, qualifier2Instance); } qualifier2Instance.Add(alias, instance); return instance; } } } } return null; } public T FindObjectOfType&lt;T&gt;(string alias = null) where T : class { return FindObjectOfType(typeof(T), alias) as T; } public List&lt;object&gt; FindObjectsOfType(Type type) { return _FindObjectsOfType(typeof(object), o =&gt; o); } public List&lt;T&gt; FindObjectsOfType&lt;T&gt;() where T : class { return _FindObjectsOfType(typeof(T), o =&gt; o as T); } public List&lt;object&gt; GetAllObjects() { return _Instances; } public List&lt;BeanMethods&gt; FindMethods&lt;A&gt;() where A : Attribute { return FindMethods(typeof(A)); } public List&lt;BeanMethods&gt; FindMethods(Type attribute) { List&lt;BeanMethods&gt; beanMethodses = new List&lt;BeanMethods&gt;(); foreach (var instance in _Instances) { var type = instance.GetType(); var methods = Reflections.GetMethods(type, attribute); if (methods == null || methods.Count == 0) { continue; } beanMethodses.Add(new BeanMethods(instance, methods)); } return beanMethodses; } public BeanMethods FindMethods(object obj, Type attribute) { var type = obj.GetType(); var methods = Reflections.GetMethods(type, attribute); if (methods == null || methods.Count == 0) { return null; } return new BeanMethods(obj, methods); } private object _Instance(Type type) { return Activator.CreateInstance(type); } private List&lt;T&gt; _FindObjectsOfType&lt;T&gt;(Type type, Func&lt;object, T&gt; mapper) where T : class { List&lt;T&gt; list = new List&lt;T&gt;(); foreach (object instance in _Instances) { var objType = instance.GetType(); if(type.IsAssignableFrom(objType)) { list.Add(mapper(instance)); } } return list; }} 上面的实现中有几个类尚未定义,下面继续定义缺失的类. IoC容器需要的其他类定义123456/// IOC组件的Attribute/// 当自定义的类上使用了该Attribute时,那么该类会被容器自动创建[AttributeUsage(AttributeTargets.Class)]public class IOCComponent : Attribute{} 1234567/// 自动注入的Attribute/// 标记了IOCComponent的类或通过IIOCContainer.InstanceAndInject、IIOCContainer.Inject/// 创建的对象,其所有标记了Autowired的字段或属性会由IOC容器自动注入实例[AttributeUsage(AttributeTargets.Field|AttributeTargets.Property)]public class Autowired : Attribute{} 12345678910111213/// 别名修饰/// 可以用于某个类型实现两个实例.分别为两个实例命名不同名字./// 而不同的类的字段可以通过该Attribute指定注入对应命名的实例.[AttributeUsage(AttributeTargets.Field|AttributeTargets.Property|AttributeTargets.Class)]public class Qualifier : Attribute{ public string Name; public Qualifier(string name) { Name = name; }} 123456789101112131415/// 某个对象上的方法列表.后续用于一些增强处理.目前暂时用不上.public class BeanMethods{ private List&lt;MethodInfo&gt; _Methods; public object Instance; public List&lt;MethodInfo&gt; Methods { get { return _Methods; } } public BeanMethods(object obj, List&lt;MethodInfo&gt; methods) { Instance = obj; _Methods = new List&lt;MethodInfo&gt;(methods); }} OK,依然如前所述,对于接触不多的人而言,该框架信息量确实比较大,请先放松.接下来通过实际使用的例子,再深入讲解上面的源码. IoC框架使用示例定义各种测试用Manager日志管理类12345678910111213141516171819202122232425262728293031323334353637383940[IOCComponent]public class LogManager{ private LogLevel _LogLevel = LogLevel.Debug; public void Log(LogLevel level, string templte, params object[] args) { if (level &lt; _LogLevel) { return; } string msg = args == null || args.Length == 0 ? templte : string.Format(templte, args); msg = $&quot;[{level}] Frame={Time.frameCount} Time={Time.time} -- {msg}&quot;; switch (level) { case LogLevel.Debug: case LogLevel.Info: Debug.Log(msg); break; case LogLevel.Warning: Debug.LogWarning(msg); break; case LogLevel.Exception: Debug.LogException(new Exception(msg)); break; case LogLevel.Error: Debug.LogError(msg); break; } }}public enum LogLevel{ Debug, Info, Warning, Exception, Error} 该类只是用于做简单的日志记录,会被后续其他Manager依赖使用. 注意到这个管理类上使用IOCComponent这一Attribute进行修饰.后续其他管理类也是如此.后续会解释为什么要这么做. 协程管理类123456789101112131415161718192021[IOCComponent]public class CoroutineManager{ private CoroutineRunner _CoroutineRunner; public CoroutineManager() { var go = new GameObject(&quot;CoroutineRunner&quot;); _CoroutineRunner = go.AddComponent&lt;CoroutineRunner&gt;(); GameObject.DontDestroyOnLoad(go); } public void StartCoroutine(IEnumerator enumerator) { _CoroutineRunner.StartCoroutine(enumerator); }}public class CoroutineRunner : MonoBehaviour{} 该类只是用于简单的协程调用,会被后续其他Manager依赖使用 资源管理类123456789101112131415161718192021222324[IOCComponent]public class AssetManager{ [Autowired] private CoroutineManager _CoroutineManager; [Autowired] private LogManager _LogManager; public void LoadAsync&lt;T&gt;(string assetPath, Action&lt;T&gt; onLoaded) where T : Object { _CoroutineManager.StartCoroutine(_LoadAsync(assetPath, onLoaded)); } private IEnumerator _LoadAsync&lt;T&gt;(string assetPath, Action&lt;T&gt; onLoaded) where T : Object { _LogManager.Log(LogLevel.Debug, &quot;Loading {0}&quot;, assetPath); // Your load code here // Now just wait for some seconds for demo yield return new WaitForSeconds(3); T loadedAsset = default(T); _LogManager.Log(LogLevel.Debug, &quot;Loaded {0} asset={1}&quot;, assetPath, loadedAsset); onLoaded?.Invoke(loadedAsset); }} 资源管理类,可以看到该类依赖了CoroutineManager和LogManager,但是没有对外提供这两个对象的设置. GameObject管理类12345678910111213141516171819202122[IOCComponent]public class GameObjectManager{ [Autowired] private AssetManager _AssetManager; [Autowired] private LogManager _LogManager; public void Instantiate(string assetPath, Action&lt;GameObject&gt; onLoaded) { _AssetManager.LoadAsync(assetPath, (GameObject prefab) =&gt; { if (prefab == null) { _LogManager.Log(LogLevel.Debug, &quot;Failed to instantiate {0}&quot;, assetPath); return; } var go = GameObject.Instantiate(prefab); onLoaded?.Invoke(go); }); }} GameObject管理类,可以看到该类也依赖了CoroutineManager和LogManager,和AssetManager一样没有对外提供这两个对象的设置. 那么,这样的代码是否能工作呢,我们接着编写测试类. 测试依赖注入123456789101112131415public class BasicDemo : MonoBehaviour{ private void Awake() { var typeContainer = new TypeContainerCollection(new [] { new TypeContainer(Assembly.GetExecutingAssembly()), new TypeContainer(typeof(IOCComponent).Assembly) }); var iocContainer = new IOCContainer(typeContainer); GameObjectManager gameObjectManager = iocContainer.FindObjectOfType&lt;GameObjectManager&gt;(); gameObjectManager.Instantiate(&quot;&quot;, null); }} 可以看到,这个类主要就是创建了一个IoC容器IOCContainer对象,接着从该容器中查找GameObjectManager,接着通过GameObjectManager实例化一个对象. 可以把该类挂到场景中任意对象上,然后运行场景.发现Unity会输出以下Log. 可以看到,我们并没有手动为各个Manager传入依赖,但是目前而言,通过IOCContainer为我们自动创建的Manager确实自动注入了依赖. 为何能实现注入那么是什么时候创建了各个管理器的实例,又是什么时候设置了管理器之间的依赖.我们重新对IOCContainer的构造函数进行分析. IOCContainer的构造函数12345678910111213141516171819202122public IOCContainer(ITypeContainer typeContainer){ _TypeContainer = typeContainer; /* 1 */ var inheritedFromIOCComponent = Reflections.GetTypes(_TypeContainer, typeof(IOCComponent)); /* 2 */ var typesWithIOCComponent = Reflections.GetTypesWithAttributes(_TypeContainer, inheritedFromIOCComponent); /* 3 */ foreach (var type in typesWithIOCComponent) { _Instances.Add(_Instance(type)); } /* 4 */ // Inject all type's field or property foreach (var instance in _Instances) { Inject(instance); }} 注释1的代码表示从_TypeContainer中获取从IOCComponent这一Attribute继承的所有Attribute,如果_TypeContainer中包含了IOCComponent,那么返回的列表中也会有IOCComponent. _TypeContainer为ITypeContainer类型,顾名思义,它是类型容器,用于返回我们可能需要处理的所有类型.具体使用我会在Unity-Reflection库中补充文档说明. 注释2的代码表示从_TypeContainer中获取类型列表,该列表中的类型需要满足:类上使用了inheritedFromIOCComponent列表中任意Attribute进行修饰.其实按我们目前的例子看,由于我们的所有Manager都使用了IOCComponent进行修饰,那么这里的列表如果仅包含IOCComponent,应当也能查询到我们定义的管理类.那么为什么不直接使用new List&lt;Type&gt; { typeof(IOCComponent) }替代注释1返回的inheritedFromIOCComponent呢.这是因为我想增加一点拓展性.当你想让自己定义的Attribute也能被IOCContainer识别时,你的Attribute可以从IOCComponent继承,那么注释1将能找到你自己定义的Attribute,此时你用自己定义的Attribute修饰类时,该类也能被查找到. 注释3的循环作用为遍历注释2返回的类型列表,并且调用_Instance方法将其实例化,并添加到_Instances列表中,以便后续有其他查找需求.目前_Instance方法只是简单通过Activator.CreateInstance(type);创建了实例并返回. 注释4的循环作用为遍历注释3实例化的_Instances列表,并调用Inject方法进行字段的依赖注入.我们的各个Manager字段的注入就是在此方法中进行的.接下来详细讲解Inject方法 Inject方法12345678910111213141516171819202122232425262728293031323334353637383940public void Inject(object obj, bool recursive = false){ if (obj == null) { return; } if (obj.GetType().IsPrimitive) { return; } if (recursive) { /* 1 */ if (_InjectedObj.Contains(obj)) { return; } _InjectedObj.Add(obj); } /* 2 */ var propertiesOrFields = Reflections.GetPropertiesAndFields&lt;Autowired&gt;(obj); foreach (var propertyOrField in propertiesOrFields) { var qualifier = propertyOrField.GetCustomAttribute&lt;Qualifier&gt;(); /* 3 */ var fieldValue = FindObjectOfType(propertyOrField.GetFieldOrPropertyType(), qualifier != null ? qualifier.Name : null); /* 4 */ propertyOrField.SetValue(obj, fieldValue); if (recursive) { /* 5 */ Inject(fieldValue, true); } }} 该方法主要用于对字段进行依赖注入. 注释1主要用于当需要递归注入时,如果发现一个对象已经注入过,则跳过,防止递归陷入死循环. 注释2获取obj中所有使用Autowired这一Attribute修饰的字段或属性.Autowired为前面定义的Attribute,我们通过这一Attribute标识哪些字段需要容器自动注入. 注释3通过FindObjectOfType从IoC容器中找到类型和字段或属性类型相匹配的对象,如果字段或属性上使用过了Qualifier指定了实例名字,查找则会同时匹配类型和名字.我们后面再细讲FindObjectOfType是如何实现的. 注释4将注释3找到的对象设置进字段,完成该字段注入. 注释5如果开启递归注入,则对该字段的值也进行注入. FindObjectOfType方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public object FindObjectOfType(Type type, string alias = null){ if (string.IsNullOrEmpty(alias)) { /* 1-Start */ if (_FindCache.ContainsKey(type)) { return _FindCache[type]; } /* 1-End */ foreach (object instance in _Instances) { /* 2-Start */ if(type.IsAssignableFrom(instance.GetType())) { _FindCache.Add(type, instance); return instance; } /* 2-End */ } } else { if (_FindCacheWithQualifier.ContainsKey(type)) { var qualifier2Instance = _FindCacheWithQualifier[type]; if (qualifier2Instance.ContainsKey(alias)) { return qualifier2Instance[alias]; } } foreach (object instance in _Instances) { var objType = instance.GetType(); if(type.IsAssignableFrom(objType)) { var qualifierAttr = objType.GetCustomAttribute(typeof(Qualifier)) as Qualifier; if (qualifierAttr != null &amp;&amp; string.Equals(qualifierAttr.Name, alias)) { Dictionary&lt;string, object&gt; qualifier2Instance = null; if (_FindCacheWithQualifier.ContainsKey(type)) { qualifier2Instance = _FindCacheWithQualifier[type]; } else { qualifier2Instance = new Dictionary&lt;string, object&gt;(); _FindCacheWithQualifier.Add(type, qualifier2Instance); } qualifier2Instance.Add(alias, instance); return instance; } } } } return null;} 这部分由于代码较多,且Qualifier实现还有很多优化空间,因此先讲alias为空的情况,即不限制别名匹配实例的情况. 注释1-Start到注释1-End中间的代码为从_FindCache中进行查找.如果之前已经通过该方法查到过该类型,那么该类型会进入_FindCache缓存,后续查找的时间复杂度就仅为O(1). 注释2-Start到注释2-End中间的代码为从已经实例化的_Instances中查找有没有能赋值给type类型的对象,如果有,则加入到_FindCache缓存并且返回结果.可以发现这里使用了Type.IsAssignableFrom进行类型匹配,因此如果你的字段使用了接口或某个父类,也能正常进行注入.接下来我们增加一个ILogManager接口测试一下. 将LogManager改为接口新增接口ILogManager12345678910111213public interface ILogManager{ public void Log(LogLevel level, string templte, params object[] args);}public enum LogLevel{ Debug, Info, Warning, Exception, Error} 新增ILogManager接口,并将LogManager中的枚举LogLevel删移动过来. 修改LogManager12345678910111213141516171819202122232425262728293031[IOCComponent]public class LogManager : ILogManager{ private LogLevel _LogLevel = LogLevel.Debug; public void Log(LogLevel level, string templte, params object[] args) { if (level &lt; _LogLevel) { return; } string msg = args == null || args.Length == 0 ? templte : string.Format(templte, args); msg = $&quot;[{level}] Frame={Time.frameCount} Time={Time.time} -- {msg}&quot;; switch (level) { case LogLevel.Debug: case LogLevel.Info: Debug.Log(msg); break; case LogLevel.Warning: Debug.LogWarning(msg); break; case LogLevel.Exception: Debug.LogException(new Exception(msg)); break; case LogLevel.Error: Debug.LogError(msg); break; } }} 让LogManager实现ILogManager接口 修改AssetManager的字段1234567891011121314151617181920212223242526[IOCComponent]public class AssetManager{ [Autowired] private CoroutineManager _CoroutineManager; [Autowired] /* 1 */ private ILogManager _LogManager; public void LoadAsync&lt;T&gt;(string assetPath, Action&lt;T&gt; onLoaded) where T : Object { _CoroutineManager.StartCoroutine(_LoadAsync(assetPath, onLoaded)); } private IEnumerator _LoadAsync&lt;T&gt;(string assetPath, Action&lt;T&gt; onLoaded) where T : Object { _LogManager.Log(LogLevel.Debug, &quot;Loading {0}&quot;, assetPath); // Your load code here // Now just wait for some seconds for demo yield return new WaitForSeconds(3); T loadedAsset = default(T); _LogManager.Log(LogLevel.Debug, &quot;Loaded {0} asset={1}&quot;, assetPath, loadedAsset); onLoaded?.Invoke(loadedAsset); }} 注释1可以看到之前字段_LogManager从LogManager类型修改为接口类型ILogManager. 同样地,将GameObjectManager中字段_LogManager从LogManager类型修改为接口类型ILogManager. 重新运行场景,发现结果和之前不使用接口是一样的. 结束以上已经一步步展示了如何实现一个简单的IoC框架.后续我们将找时间对该框架进行升级,使得其具备诸如AOP等特性. 完整的Package工程地址在https://github.com/kakashiio/Unity-IOC 使用大家也可以通过PackageManager引用:打开Unity的PackageManager并点击左上角的“+”按钮,选择&quot;Add package from git URL...&quot;,加入如下两个地址 Package地址 说明 Git地址 https://github.com/kakashiio/Unity-Reflection.git#1.0.0 IOC依赖的反射库 https://github.com/kakashiio/Unity-Reflection https://github.com/kakashiio/Unity-IOC.git#1.0.0 IOC容器库 https://github.com/kakashiio/Unity-IOC 致谢感谢百忙之中阅读本文,如果觉得我的文章帮到了你,欢迎:转载、关注git、为仓库增加star等.你的简单回馈将是我继续创作的动力.","link":"/2022/05/03/Unity-IOC/"}],"tags":[{"name":"Unity3D","slug":"Unity3D","link":"/tags/Unity3D/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"代码设计","slug":"代码设计","link":"/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"},{"name":"架构","slug":"架构","link":"/tags/%E6%9E%B6%E6%9E%84/"},{"name":"Ioc","slug":"Ioc","link":"/tags/Ioc/"}],"categories":[{"name":"Unity3D","slug":"Unity3D","link":"/categories/Unity3D/"},{"name":"代码设计与架构","slug":"Unity3D/代码设计与架构","link":"/categories/Unity3D/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/"},{"name":"C#","slug":"C","link":"/categories/C/"},{"name":"代码设计与架构","slug":"C/代码设计与架构","link":"/categories/C/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/"}]}