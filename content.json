{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"About me","text":"Demo VideosDemostrates made by me. One Piece Battle Demo Shows What Could 2 People Do In One Month I finish this whole demo with one artist in one month from zero. Battle Demo Shows Fighting With Mass Unit Performance. Support fighting with more than 100 units simultaneously in mobile Battle Demo Shows Fighting With Boss AI &amp; Fight System. More tactics battle system and more natural BOSS AI. Programmers or Designers need little or no code to implement such a fight. Demo Shows Exploring In OpenWorld Open World.Explore in open world as you wish in mobile. Skill Logic Editor Skill System. Powerfull skill editor support custom complex skill Bullet Editor Bullet System. Powerfull bullet editor support custom complex bullet Camera Mode Abstracter Camera Mode Abstracter help to switch camera mode in different game types (such as FPS、TPS、TopDown ACT etc) without any R&amp;D costs Sakazuki‘s Skill Preview The Legend of Heroes:Trails in the Sky ARPG Battle Demo SRPG Battle Demo 01 SRPG Battle Demo 02 Code S Battle Demo High performance volumetric fog in mobile Environment Rain &amp; Lightning Mo Dao Zu Shi Battle Demo Tokyo Ghoul Enviroment Preview StarMaker VR Avatar Taiko Music &amp; Dance Try Art &amp; Render Collection Work Experience2020~2023 GameArk &amp; StarMaker (http://www.kunlun.com/ &amp; https://www.starmakerstudios.com/)Technical Director &amp; Product ProducerResponsible for game architecture, design, development, optimization and management of The Legend of Sword and Fairy(3D MMO RPG Mobile Game), Code S (3D RPG Mobile Game), One Piece(3D ARPG Mobile Game), StarMakerVR (VR Game); In charge of the recruitment and management technical center team. Project One Piece Established AAA mobile game workflow Designed and implemented Open World solutions Developed a set of low-code combat, AI and level system Demo Videos Battle Demo Shows What Could 2 People Do In One Month I finish this whole demo with one artist in one month from zero. Battle Demo Shows Fighting With Mass Unit Performance. Support fighting with more than 100 units simultaneously in mobile Battle Demo Shows Fighting With Boss AI &amp; Fight System. More tactics battle system and more natural BOSS AI. Programmers or Designers need little or no code to implement such a fight. Demo Shows Exploring In OpenWorld Open World.Explore in open world as you wish in mobile. Skill Logic Editor Skill System. Powerfull skill editor support custom complex skill Bullet Editor Bullet System. Powerfull bullet editor support custom complex bullet Camera Mode Abstracter Camera Mode Abstracter help to switch camera mode in different game types (such as FPS、TPS、TopDown ACT etc) without any R&amp;D costs Sakazuki‘s Skill Preview StarMakerVR Encapsulated the cross-platform VR development library (supports the expansion of various VR platforms) Designed and implemented the framework of online Karaoke and social network Constructed a VR development tool set, supporting an ordinary programmer to develop a VR game within a month Supported dynamic module expansion of games (currently there are 4 games in StarMaker that can be added modules freely for expansion) Demo Videos Avatar Taiko Music &amp; Dance Try The Legend of Sword and Fairy &amp; Code S Real-Time Lighting: Skill can light objects real-time Environmental Rendering: Real-time weather system Environmental Rendering: The terrain system supports more terrain textures Environmental Rendering: Interactive vegetation Render Performance: Reach the same performance of competitor while achieving better imagery Demo Videos Battle Demo High performance volumetric fog in mobile Environment Rain &amp; Lightning 2018~2020 360 Game (https://www.360.com)Technical DirectorResponsible for architecture design, technical framework construction, rendering effect and performance optimization, and R&amp;D management of IP projects Mo Dao Zu Shi(3D RPG Mobile Game), Tokyo Ghoul(3D ARPG Mobile Game), The Legend of Heroes:Trails in the Sky(3D SRPG Mobile Game) Project Mo Dao Zu Shi Build the production pipeline of AAA mobile games Developed RPG combat framework Demo Videos Battle Demo The Legend of Heroes:Trails in the Sky Developed SRPG/ACT combat framework Demo Videos ARPG Battle Demo SRPG Battle Demo 01 SRPG Battle Demo 02 Tokyo Ghoul Unity rendering effect and rendering performance optimization Environment Rendering:Depth Fog and Height Fog Shader CGINC Character Rendering:Cartoon PBR Shader Post Process performance optimization Demo Videos Enviroment Preview 2015~2018 Guangzhou Simulate Science and Technology Ltd.Co-founder &amp; CTOIn charge of server architecture design, R&amp;D, operation and maintenance of Billionaire City (2D OpenWorld Build &amp; Simulation Mobile Game), Jump Travel (3D Casual Social Mobile Game) and R&amp;D management. Project Billionaire City Obtained angel investment of 2 million dollars Independently developed a set of simulation management + city construction big world server that supports high concurrency Multiple featured by GooglePlay Store Rated 9.0 on TapTap (TOP 1 Mobile Game Store in China) Jump Travel Developed a low-code game server framework, which can realize countless ultra-casual games through configuration 2013~2015 Multi-Entertainment Science and Technology Ltd.Founder (CEO &amp; CTO)Responsible for the founding, fundraising, project setup, R&amp;D, operation and management of the entire company Project Star Wars(3D TRPG Mobile Game) Obtained angel investment of 200k dollars Full-stack development, built a whole set of front-end and back-end frameworks that can support rollback alone Developed Unity tools to support automation of art work process 2011~2013 Hainan Dongwangxianfeng Science and Technology Ltd. (http://cndw.com/)Chief programmer of Game ServerIn charge of the server architecture, R&amp;D and management of Story of the Twin Dragons of Great Tang(RPG Web Game), Journey to the West:Conquering the Demons(ARPG Web Game) Project Story of the Twin Dragons of Great Tang Designed and implemented the company’s first cache-based game server framework Wrote 70% of server code Launched on Tencent’s all platforms including QQ, QZone, QGame, 3366, with 800,000 online users active at the same time Won the 2011 Top Ten New Web Game in 265G league table Journey to the West:Conquering the Demons The company’s first ARPG Web Game Gained authorization from Stephen Chow’s to launch its same-name game of film Wild Journey to Conquer the Demons Designed and implement the company’s first multi-threaded and high-concurrency real-time game server framework Completed the server code writing for a whole set of character occupations, battles, skills, and levels alone Other Experience Translated and published the book Unity In Action, ranking Top 1 in the best-selling Amazon Game Development in four consecutive months. Translated and published the book Unity Game Optimization, added a chapter to the third edition of original book Owned 2.2K followers and 1.1M visits in China’s largest technical blog community Tech consultant for Xinpai Media VisionDesign, develop and build a greate game! GithubKakashi’s github","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Unity-IOC-Unity","text":"此类库为IOC库的拓展,旨在提升Unity项目开发便捷性甚至性能.以更优雅、便捷和高性能的方式响应Unity提供的各种事件回调. 入门添加引用通过Package Manager添加如下依赖: Package Description https://github.com/kakashiio/Unity-Reflection.git#1.0.0 Reflection库 https://github.com/kakashiio/Unity-IOC.git#1.0.0 IOC库 https://github.com/kakashiio/Unity-IOC-Unity.git#1.0.0 IOC-Unity库 创建一个UnityIOCContainer1234567ITypeContainer typeContainer = new TypeContainerCollection(new List&lt;ITypeContainer&gt; { new TypeContainer(Assembly.GetExecutingAssembly()), new TypeContainer(typeof(UnityIOCContainer).Assembly), new TypeContainer(typeof(IOCContainer).Assembly) }); new UnityIOCContainer(typeContainer); 将上述代码添加到你应用程序启动的位置. 根据需要实现一下Unity相关的接口 IUnityUpdate IUnityLateUpdate IUnityFixedUpdate IUnityGUI IUnityApplication IUnityEditor 假设你希望每帧调用一段代码.传统的方式为创建一个MonoBehaviour,在该MonoBehaviour的Update方法中增加你的方法.而通过上面添加引用引入的IOC库和IOC-Unity之后,可以使用以下代码实现: 12345678[IOCComponent]public class NormalClassButNotMonoBehaviour : IUnityUpdate{ public void Update() { // 需要每帧执行的代码. }} 这样就轻松实现了上述需求. IUnityUpdate的代码为IOC-Unity库提供,其代码非常简单,如下所示: 1234public interface IUnityUpdate{ void Update();} 这种方式甚至比传统方式性能更高! 其他组件CoroutineManager用于帮助更方便执行协程.如果你希望执行一些协程,那么可以编写如下代码: 123456789101112131415161718192021222324252627282930313233[IOCComponent]public class HttpManager4Demo : IUnityGUI{ [Autowired] private CoroutineManager _CoroutineManager; public void Get(string url, Action&lt;string&gt; onGet) { _CoroutineManager.StartCoroutine(_StartGet(url, onGet)); } private IEnumerator _StartGet(string url, Action&lt;string&gt; onGet, Action&lt;string&gt; onError = null) { UnityWebRequest unityWebRequest = UnityWebRequest.Get(url); yield return unityWebRequest.SendWebRequest(); if (unityWebRequest.result == UnityWebRequest.Result.Success) { onGet?.Invoke(unityWebRequest.downloadHandler.text); } else { onError?.Invoke(unityWebRequest.error); } } public void OnGUI() { if (GUILayout.Button(&quot;Get&quot;)) { Get(&quot;https://unity3d.io&quot;, (msg) =&gt; Debug.Log(msg)); } }} 未来会增加更多Unity API和组件支持以加速游戏开发. 如果你有更好建议,也期待你指出. 完整的Package工程地址在https://github.com/kakashiio/Unity-IOC-Unity 致谢感谢百忙之中阅读本文,如果觉得我的文章帮到了你,欢迎:转载、关注git、为仓库增加star等.你的简单回馈将是我继续创作的动力.","link":"/2022/05/09/Unity-IOC-Unity/"},{"title":"Unity-IOC-Event","text":"此类库为IOC库的拓展,旨在实现一个自动注册事件的事件管理器.不再需要像传统项目中自己手动Register或Unregister事件. 添加引用通过Package Manager添加如下依赖: Package Description https://github.com/kakashiio/Unity-Reflection.git#1.0.0 Reflection库 https://github.com/kakashiio/Unity-IOC.git#1.0.0 IOC库 https://github.com/kakashiio/Unity-IOC-Event.git#1.0.0 IOC-Event库 示例1:全局事件基础假设我们希望实现如下游戏流程: 当IOCContainer初始化完成时,触发EventInit事件 GameFlowController监听所有事件并做出响应 当收到EventInit事件时 打印[GameFlow] OnInit 触发EventFinishInit事件 当收到EventFinishInit事件时 打印[GameFlow] OnFinishInit 触发EventLoadingMain,此时进度为0 进行场景加载 当收到EventLoadingMain事件时 打印[GameFlow] OnLoadingMain 进度值 当收到EventLoadedScene事件时 打印[GameFlow] OnEnterScene scene=当前激活的场景 创建一个IOCContainer12345678ITypeContainer typeContainer = new TypeContainerCollection(new List&lt;ITypeContainer&gt; { new TypeContainer(Assembly.GetExecutingAssembly()), new TypeContainer(typeof(IOCComponent).Assembly), new TypeContainer(typeof(EventManager).Assembly) }); new IOCContainerBuilder(typeContainer).Build(); 将上述代码添加到你应用程序启动的位置. 先定义所需的事件1234567891011121314151617181920212223class EventInit : EventArg {}class EventFinishInit : EventArg {}class EventLoadingMain : EventArg{ public float Progress; public EventLoadingMain(float progress) { Progress = progress; }}class EventLoadedScene : EventArg{ public Scene Scene; public EventLoadedScene(Scene scene) { Scene = scene; }} 定义Game以响应IOCContainer的生命周期12345678910111213141516171819[IOCComponent]class Game : IInstanceLifeCycle{ [Autowired] private EventManager _EventManager; public void BeforePropertiesOrFieldsSet() { } public void AfterPropertiesOrFieldsSet() { } public void AfterAllInstanceInit() { _EventManager.FireEvent&lt;EventInit&gt;(); }} 定义GameFlowController响应事件1234567891011121314151617181920212223242526272829303132333435363738[IOCComponent]class GameFlowController{ [Autowired] private AssetLoader _AssetLoader; [Autowired] private EventManager _EventManager; [Event] public void OnInit(EventInit eventInit) { Debug.LogError(&quot;[GameFlow] OnInit&quot;); _EventManager.FireEvent&lt;EventFinishInit&gt;(); } [Event] public void OnFinishInit(EventFinishInit eventFinishInit) { Debug.LogError(&quot;[GameFlow] OnFinishInit&quot;); _EventManager.FireEvent(new EventLoadingMain(0)); _AssetLoader.LoadScene(&quot;ScenePath&quot;, (scene) =&gt; { _EventManager.FireEvent(new EventLoadingMain(100)); }); } [Event] public void OnLoadingMain(EventLoadingMain eventLoadingMain) { Debug.LogError($&quot;[GameFlow] OnLoadingMain {eventLoadingMain.Progress}&quot;); } [Event] public void OnEnterScene(EventLoadedScene eventLoadedScene) { Debug.LogError($&quot;[GameFlow] OnEnterScene scene={eventLoadedScene.Scene}&quot;); }} 定义AssetLoader模拟资源加载12345678910111213[IOCComponent]class AssetLoader{ [Autowired] private EventManager _EventManager; public void LoadScene(string scenePath, Action&lt;Scene&gt; onLoadedScene) { var scene = SceneManager.GetActiveScene(); onLoadedScene(scene); _EventManager.FireEvent(new EventLoadedScene(scene)); }} 所有工作完成运行场景会发现控制台中按顺序出现如下输出: 12345[GameFlow] OnInit[GameFlow] OnFinishInit[GameFlow] OnLoadingMain 0[GameFlow] OnLoadingMain 100[GameFlow] OnEnterScene scene=UnityEngine.SceneManagement.Scene 很神奇,对吧!IOCContainer和EventManager帮助你将IOCContainer中所有带有Event attribute的方法注册到EventManager中,因此当调用EventManager的FireEvent时,对应的方法将会被自动调用. 该例子适合于类似全局事件注册,比如网络消息注册等,此类消息的特点为只要整个游戏还在运行中,那么这类消息被永久监听,不会从监听中移除. 那么对于类似UI界面的消息需求,有的时候只需要在打开UI时监听,在关闭UI时移除监听.该EventManager也是支持的. 示例2:局部事件基础假设我们希望实现如下游戏流程: 当IOCContainer初始化完成时: 通过UIManager打开BagUI 触发EventBagItemDataChange事件,将ID为1的物件的Count更新为100 触发EventBagItemDataChange事件,将ID为1的物件的Count更新为200 触发EventBagDeleteItem事件,将ID为1的物件移除 通过UIManager关闭BagUI 触发EventBagItemDataChange事件,将ID为1的物件的Count更新为300 触发EventBagDeleteItem事件,将ID为2的物件移除 注意观察BagUI能否收到第6步和第7的事件 创建一个IOCContainer12345678ITypeContainer typeContainer = new TypeContainerCollection(new List&lt;ITypeContainer&gt; { new TypeContainer(Assembly.GetExecutingAssembly()), new TypeContainer(typeof(IOCComponent).Assembly), new TypeContainer(typeof(EventManager).Assembly) }); new IOCContainerBuilder(typeContainer).Build(); 将上述代码添加到你应用程序启动的位置. 定义事件12345678910111213141516171819202122232425262728293031class EventBagItemDataChange : EventArg{ public int ID; public int Count; public EventBagItemDataChange(int id, int count) { ID = id; Count = count; } public override string ToString() { return $&quot;ID={ID} Count={Count}&quot;; }}class EventBagDeleteItem : EventArg{ public int ID; public EventBagDeleteItem(int id) { ID = id; } public override string ToString() { return $&quot;ID={ID}&quot;; }} 定义背包BagUI12345678910111213class BagUI{ [Event] public void OnBagDataChange(EventBagItemDataChange eventBagItemDataChange) { Debug.LogError($&quot;[OnBagDataChange] {eventBagItemDataChange}&quot;); } [Event] public void OnEventBagDeleteItem(EventBagDeleteItem eventBagDeleteItem) { Debug.LogError($&quot;[OnEventBagDeleteItem] {eventBagDeleteItem}&quot;); }} 该UI为了演示对事件的监听,目前没有任何逻辑,仅仅在收到事件时进行打印. 定义一个用于辅助测试的UIManager12345678910111213141516171819202122232425262728293031323334353637[IOCComponent]class UIManager { [Autowired] private EventManager _EventManager; private IIOCContainer _IOCContainer; private Dictionary&lt;Type, object&gt; _UIs = new Dictionary&lt;Type, object&gt;(); public void Open&lt;T&gt;(Action&lt;T&gt; onOpened) where T : new() { var uiType = typeof(T); if (_UIs.ContainsKey(uiType)) { onOpened((T) _UIs[uiType]); return; } var t = new T(); _EventManager.Register(t); _UIs.Add(uiType, t); onOpened.Invoke(t); } public void Close&lt;T&gt;() { var uiType = typeof(T); if (!_UIs.ContainsKey(uiType)) { return; } var ui = _UIs[uiType]; _UIs.Remove(uiType); _EventManager.Unregister(ui); }} 可以看到每次Open时,我们将创建的UI对象通过Register方法注册到EventManager中,而每次Close时,我们将创建的UI对象注册的所有事件通过Unregister方法从EventManager中移除.可以看到不需要自己将BagUI中的对象一个个地进行注册和反注册.EventManager.Register(object)方法将object中所有带有Event attribute的方法注册到事件管理器中. 定义Game进行最终测试123456789101112131415161718192021222324252627[IOCComponent]class Game : IInstanceLifeCycle{ [Autowired] private UIManager _UIManager; [Autowired] private EventManager _EventManager; public void BeforePropertiesOrFieldsSet() { } public void AfterPropertiesOrFieldsSet() { } public void AfterAllInstanceInit() { _UIManager.Open&lt;BagUI&gt;((ui) =&gt; { }); _EventManager.FireEvent(new EventBagItemDataChange(1, 100)); _EventManager.FireEvent(new EventBagItemDataChange(1, 200)); _EventManager.FireEvent(new EventBagDeleteItem(1)); _UIManager.Close&lt;BagUI&gt;(); _EventManager.FireEvent(new EventBagItemDataChange(1, 300)); _EventManager.FireEvent(new EventBagDeleteItem(2)); }} 所有工作完成运行场景会发现控制台中按顺序出现如下输出: 123[OnBagDataChange] ID=1 Count=100[OnBagDataChange] ID=1 Count=200[OnEventBagDeleteItem] ID=1 可以看到当调用_UIManager.Close&lt;BagUI&gt;()后,BagUI没有触发另外两个事件.这正是我们所预期的效果. 工程地址完整的Package工程地址在https://github.com/kakashiio/Unity-IOC-Event 致谢感谢百忙之中阅读本文,如果觉得我的文章帮到了你,欢迎:转载、关注git、为仓库增加star等.你的简单回馈将是我继续创作的动力.","link":"/2022/05/10/Unity-IOC-Event/"},{"title":"Unity-IOC","text":"本文目的向大家介绍: 在开发中为何要使用IoC 如何开实现一个精简的IoC 使用IoC前后代码带来怎样的变化 我当前在开发的IoC类库 如果你对1、2、3都已经很熟了,并且对我的项目感兴趣,可以直接跳我的IoC仓库.完整的工程地址在https://github.com/kakashiio/Unity-IOC,该IoC仓库也是我的Unity游戏框架计划https://github.com/kakashiio/Unity-SourceFramework中的一部分. 为什么要使用IoC想象一下,当你在实现一个UI管理器UIManager时,当在UIManager中需要加载UI资源时,你是通过何种方式加载资源的. 一般开发诸如AssetManager、TimeManager、EventManager等管理器(Manager)时.喜欢采用静态方法或单例.这样做是为了使得项目能方便地引用这些管理器. 常见的实现代码: 1234567891011121314public class UIManager{ public void Create&lt;T&gt;(Action&lt;T&gt; onCreate) where T : IUI { string assetPath = _GetAssetPath&lt;T&gt;(); AssetManager.Instantiate&lt;GameObject&gt;((go)=&gt;{ var t = new T(); t.Init(go); onCreate?.Invoke(t); }); }} 或 123456789101112public class UIManager{ public void Create&lt;T&gt;(Action&lt;T&gt; onCreate) where T : IUI { string assetPath = _GetAssetPath&lt;T&gt;(); Singleton&lt;AssetManager&gt;.Instance.Instantiate&lt;GameObject&gt;((go)=&gt;{ var t = new T(); t.Init(go); onCreate?.Invoke(t); }); }} 虽然静态方法或单例都能实现想要的效果,但或多或少会带来负面的效果.比如耦合严重,难以测试等等.因此本文引入一种已经很成熟的设计思路IoC,一步步实现一个简单的IoC容器,并且将IoC应用到实际中.大家也可以对比感受引入IoC前后代码发生的变化. IoC简述IoC(Inversion of Control,控制反转)通常也被称为DI(Dependency Injection,依赖注入).他是将传统对象依赖从内部指定改为外部决定的过程.比如上面的UIManager中内部指定了使用AssetManager.当使用IoC设计时,代码会修改为: 1234567891011121314151617181920public class UIManager{ private IAssetManager _AssetManager; public UIManager(IAssetManager assetManager) { _AssetManager = assetManager; } public void Create&lt;T&gt;(Action&lt;T&gt; onCreate) where T : IUI { string assetPath = _GetAssetPath&lt;T&gt;(); _AssetManager.Instantiate&lt;GameObject&gt;((go)=&gt;{ var t = new T(); t.Init(go); onCreate?.Invoke(t); }); }} 这是引入IoC最简单的例子,即把内部采用哪个IAssetManager实现的权力转移给外部,因此称为IoC(Inversion of Control,控制反转),由于UIManager依赖了IAssetManager而且将其实现通过外部构造传入,因此也称DI(Dependency Injection,依赖注入). 但是这样的代码明显不够方便,因为需要自己在构造时传入IAssetManager,如果只是UIManager需要传入IAssetManager实例还好,实际上可以预见的是SceneManager、UnitManager、EffectManager等类可能都需要IAssetManager,那么最终可能会有类似这样的代码: 123456789101112public class Main{ public void Init() { var assetManager = new AssetManager(); var uiManager = new UIManager(assetManager); var sceneManager = new SceneManager(assetManager); var unitManager = new UnitManager(assetManager); var effectManager = new EffectManager(assetManager); // ... }} 这样的代码重复、而且没有意义、不同的人反复在这里添加自己的代码也容易引发冲突和错误.我们应该编写一个更智能的IoC框架来帮助我们完成这些事情. 编写IoC框架添加依赖由于我们需要大量使用反射完成一些工作,因此通过PackageManager依赖我之前开源的用于反射的Packagehttps://github.com/kakashiio/Unity-Reflection 打开Unity的PackageManager并点击左上角的“+”按钮,选择&quot;Add package from git URL...&quot;并填入该地址https://github.com/kakashiio/Unity-Reflection.git#1.0.0 IoC容器定义IoC容器接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public interface IIOCContainer{ /// &lt;summary&gt; /// 实例化`type`类型的对象并注入其所有字段和属性 /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; object InstanceAndInject(Type type); /// &lt;summary&gt; /// 实例化类型为`T`的对象并注入其所有字段和属性 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; T InstanceAndInject&lt;T&gt;(); /// &lt;summary&gt; /// 为一个已存在的对象`obj`注入其所有字段和属性 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;recursive&quot;&gt; /// 如果recursive == true, 那么instance的字段也会被递归注入 /// &lt;/param&gt; void Inject(object obj, bool recursive = false); /// &lt;summary&gt; /// 查找`type`类型或`type`类型子类的对象. /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; object FindObjectOfType(Type type); /// &lt;summary&gt; /// 查找`T`类型或`T`类型子类的对象. /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; T FindObjectOfType&lt;T&gt;() where T : class; /// &lt;summary&gt; /// 查找所有`type`类型或`type`类型子类的对象. /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; List&lt;object&gt; FindObjectsOfType(Type type); /// &lt;summary&gt; /// 查找所有`T`类型或`T`类型子类的对象. /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; List&lt;T&gt; FindObjectsOfType&lt;T&gt;() where T : class;} IIOCContainer接口主要定义了一个IOC容器对外提供的服务.比如外部可以通过FindObjectOfType查找某个类型在容器中创建的实例、或者通过InstanceAndInject创建一个指定类型的对象,InstanceAndInject方法与new创建对象不同在于InstanceAndInject创建的对象会被容器管理,同时会自动按设计的约定注入字段. 这里每个方法都写了比较详细的注释.如果目前大家还不是很清楚,主要可能是对于IoC还不太熟悉,这关系不大.后面会通过实际使用的例子回过来深入介绍细节.接下来先把该接口的实现和另外几个比较重要的类的源码给出来,目前大家只要先大概浏览一下即可. 实现IoC容器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public class IOCContainer : IIOCContainer{ private ITypeContainer _TypeContainer; private List&lt;object&gt; _Instances = new List&lt;object&gt;(); private HashSet&lt;object&gt; _InjectedObj = new HashSet&lt;object&gt;(); private Dictionary&lt;Type, object&gt; _FindCache = new Dictionary&lt;Type, object&gt;(); public IOCContainer(ITypeContainer typeContainer) { _TypeContainer = typeContainer; var inheritedFromIOCComponent = Reflections.GetTypes(_TypeContainer, typeof(IOCComponent)); var typesWithIOCComponent = Reflections.GetTypesWithAttributes(_TypeContainer, inheritedFromIOCComponent); foreach (var type in typesWithIOCComponent) { _Instances.Add(_Instance(type)); } // Inject all type's field or property foreach (var instance in _Instances) { Inject(instance); } } public object InstanceAndInject(Type type) { var instance = _Instance(type); Inject(instance); return instance; } public T InstanceAndInject&lt;T&gt;() { return (T) InstanceAndInject(typeof(T)); } public void Inject(object obj, bool recursive = false) { if (obj == null) { return; } if (obj.GetType().IsPrimitive) { return; } if (recursive) { if (_InjectedObj.Contains(obj)) { return; } _InjectedObj.Add(obj); } var propertiesOrFields = Reflections.GetPropertiesAndFields&lt;Autowired&gt;(obj); foreach (var propertyOrField in propertiesOrFields) { var fieldValue = FindObjectOfType(propertyOrField.GetFieldOrPropertyType()); propertyOrField.SetValue(obj, fieldValue); if (recursive) { Inject(fieldValue, true); } } } public object FindObjectOfType(Type type) { if (_FindCache.ContainsKey(type)) { return _FindCache[type]; } foreach (object instance in _Instances) { if(type.IsAssignableFrom(instance.GetType())) { _FindCache.Add(type, instance); return instance; } } return null; } public T FindObjectOfType&lt;T&gt;() where T : class { return FindObjectOfType(typeof(T)) as T; } public List&lt;object&gt; FindObjectsOfType(Type type) { return _FindObjectsOfType(typeof(object), o =&gt; o); } public List&lt;T&gt; FindObjectsOfType&lt;T&gt;() where T : class { return _FindObjectsOfType(typeof(T), o =&gt; o as T); } private object _Instance(Type type) { return Activator.CreateInstance(type); } private List&lt;T&gt; _FindObjectsOfType&lt;T&gt;(Type type, Func&lt;object, T&gt; mapper) where T : class { List&lt;T&gt; list = new List&lt;T&gt;(); foreach (object instance in _Instances) { var objType = instance.GetType(); if(type.IsAssignableFrom(objType)) { list.Add(mapper(instance)); } } return list; }} 上面的实现中有几个类尚未定义,下面继续定义缺失的类. IoC容器需要的其他类定义123456/// IOC组件的Attribute/// 当自定义的类上使用了该Attribute时,那么该类会被容器自动创建[AttributeUsage(AttributeTargets.Class)]public class IOCComponent : Attribute{} 1234567/// 自动注入的Attribute/// 标记了IOCComponent的类或通过IIOCContainer.InstanceAndInject、IIOCContainer.Inject/// 创建的对象,其所有标记了Autowired的字段或属性会由IOC容器自动注入实例[AttributeUsage(AttributeTargets.Field|AttributeTargets.Property)]public class Autowired : Attribute{} OK,依然如前所述,对于接触不多的人而言,该框架信息量确实比较大,请先放松.接下来通过实际使用的例子,再深入讲解上面的源码. IoC框架使用示例定义各种测试用Manager日志管理类12345678910111213141516171819202122232425262728293031323334353637383940[IOCComponent]public class LogManager{ private LogLevel _LogLevel = LogLevel.Debug; public void Log(LogLevel level, string templte, params object[] args) { if (level &lt; _LogLevel) { return; } string msg = args == null || args.Length == 0 ? templte : string.Format(templte, args); msg = $&quot;[{level}] Frame={Time.frameCount} Time={Time.time} -- {msg}&quot;; switch (level) { case LogLevel.Debug: case LogLevel.Info: Debug.Log(msg); break; case LogLevel.Warning: Debug.LogWarning(msg); break; case LogLevel.Exception: Debug.LogException(new Exception(msg)); break; case LogLevel.Error: Debug.LogError(msg); break; } }}public enum LogLevel{ Debug, Info, Warning, Exception, Error} 该类只是用于做简单的日志记录,会被后续其他Manager依赖使用. 注意到这个管理类上使用IOCComponent这一Attribute进行修饰.后续其他管理类也是如此.后续会解释为什么要这么做. 协程管理类123456789101112131415161718192021[IOCComponent]public class CoroutineManager{ private CoroutineRunner _CoroutineRunner; public CoroutineManager() { var go = new GameObject(&quot;CoroutineRunner&quot;); _CoroutineRunner = go.AddComponent&lt;CoroutineRunner&gt;(); GameObject.DontDestroyOnLoad(go); } public void StartCoroutine(IEnumerator enumerator) { _CoroutineRunner.StartCoroutine(enumerator); }}public class CoroutineRunner : MonoBehaviour{} 该类只是用于简单的协程调用,会被后续其他Manager依赖使用 资源管理类123456789101112131415161718192021222324[IOCComponent]public class AssetManager{ [Autowired] private CoroutineManager _CoroutineManager; [Autowired] private LogManager _LogManager; public void LoadAsync&lt;T&gt;(string assetPath, Action&lt;T&gt; onLoaded) where T : Object { _CoroutineManager.StartCoroutine(_LoadAsync(assetPath, onLoaded)); } private IEnumerator _LoadAsync&lt;T&gt;(string assetPath, Action&lt;T&gt; onLoaded) where T : Object { _LogManager.Log(LogLevel.Debug, &quot;Loading {0}&quot;, assetPath); // Your load code here // Now just wait for some seconds for demo yield return new WaitForSeconds(3); T loadedAsset = default(T); _LogManager.Log(LogLevel.Debug, &quot;Loaded {0} asset={1}&quot;, assetPath, loadedAsset); onLoaded?.Invoke(loadedAsset); }} 资源管理类,可以看到该类依赖了CoroutineManager和LogManager,但是没有对外提供这两个对象的设置. GameObject管理类12345678910111213141516171819202122[IOCComponent]public class GameObjectManager{ [Autowired] private AssetManager _AssetManager; [Autowired] private LogManager _LogManager; public void Instantiate(string assetPath, Action&lt;GameObject&gt; onLoaded) { _AssetManager.LoadAsync(assetPath, (GameObject prefab) =&gt; { if (prefab == null) { _LogManager.Log(LogLevel.Debug, &quot;Failed to instantiate {0}&quot;, assetPath); return; } var go = GameObject.Instantiate(prefab); onLoaded?.Invoke(go); }); }} GameObject管理类,可以看到该类也依赖了CoroutineManager和LogManager,和AssetManager一样没有对外提供这两个对象的设置. 那么,这样的代码是否能工作呢,我们接着编写测试类. 测试依赖注入123456789101112131415public class BasicDemo : MonoBehaviour{ private void Awake() { var typeContainer = new TypeContainerCollection(new [] { new TypeContainer(Assembly.GetExecutingAssembly()), new TypeContainer(typeof(IOCComponent).Assembly) }); var iocContainer = new IOCContainer(typeContainer); GameObjectManager gameObjectManager = iocContainer.FindObjectOfType&lt;GameObjectManager&gt;(); gameObjectManager.Instantiate(&quot;&quot;, null); }} 可以看到,这个类主要就是创建了一个IoC容器IOCContainer对象,接着从该容器中查找GameObjectManager,接着通过GameObjectManager实例化一个对象. 可以把该类挂到场景中任意对象上,然后运行场景.发现Unity会输出以下Log. 可以看到,我们并没有手动为各个Manager传入依赖,但是目前而言,通过IOCContainer为我们自动创建的Manager确实自动注入了依赖. 为何能实现注入那么是什么时候创建了各个管理器的实例,又是什么时候设置了管理器之间的依赖.我们重新对IOCContainer的构造函数进行分析. IOCContainer的构造函数12345678910111213141516171819202122public IOCContainer(ITypeContainer typeContainer){ _TypeContainer = typeContainer; /* 1 */ var inheritedFromIOCComponent = Reflections.GetTypes(_TypeContainer, typeof(IOCComponent)); /* 2 */ var typesWithIOCComponent = Reflections.GetTypesWithAttributes(_TypeContainer, inheritedFromIOCComponent); /* 3 */ foreach (var type in typesWithIOCComponent) { _Instances.Add(_Instance(type)); } /* 4 */ // Inject all type's field or property foreach (var instance in _Instances) { Inject(instance); }} 注释1的代码表示从_TypeContainer中获取从IOCComponent这一Attribute继承的所有Attribute,如果_TypeContainer中包含了IOCComponent,那么返回的列表中也会有IOCComponent. _TypeContainer为ITypeContainer类型,顾名思义,它是类型容器,用于返回我们可能需要处理的所有类型.具体使用我会在Unity-Reflection库中补充文档说明. 注释2的代码表示从_TypeContainer中获取类型列表,该列表中的类型需要满足:类上使用了inheritedFromIOCComponent列表中任意Attribute进行修饰.其实按我们目前的例子看,由于我们的所有Manager都使用了IOCComponent进行修饰,那么这里的列表如果仅包含IOCComponent,应当也能查询到我们定义的管理类.那么为什么不直接使用new List&lt;Type&gt; { typeof(IOCComponent) }替代注释1返回的inheritedFromIOCComponent呢.这是因为我想增加一点拓展性.当你想让自己定义的Attribute也能被IOCContainer识别时,你的Attribute可以从IOCComponent继承,那么注释1将能找到你自己定义的Attribute,此时你用自己定义的Attribute修饰类时,该类也能被查找到. 注释3的循环作用为遍历注释2返回的类型列表,并且调用_Instance方法将其实例化,并添加到_Instances列表中,以便后续有其他查找需求.目前_Instance方法只是简单通过Activator.CreateInstance(type);创建了实例并返回. 注释4的循环作用为遍历注释3实例化的_Instances列表,并调用Inject方法进行字段的依赖注入.我们的各个Manager字段的注入就是在此方法中进行的.接下来详细讲解Inject方法 Inject方法123456789101112131415161718192021222324252627282930313233343536373839public void Inject(object obj, bool recursive = false){ if (obj == null) { return; } if (obj.GetType().IsPrimitive) { return; } if (recursive) { /* 1 */ if (_InjectedObj.Contains(obj)) { return; } _InjectedObj.Add(obj); } /* 2 */ var propertiesOrFields = Reflections.GetPropertiesAndFields&lt;Autowired&gt;(obj); foreach (var propertyOrField in propertiesOrFields) { /* 3 */ var fieldValue = FindObjectOfType(propertyOrField.GetFieldOrPropertyType()); /* 4 */ propertyOrField.SetValue(obj, fieldValue); if (recursive) { /* 5 */ Inject(fieldValue, true); } }} 该方法主要用于对字段进行依赖注入. 注释1主要用于当需要递归注入时,如果发现一个对象已经注入过,则跳过,防止递归陷入死循环. 注释2获取obj中所有使用Autowired这一Attribute修饰的字段或属性.Autowired为前面定义的Attribute,我们通过这一Attribute标识哪些字段需要容器自动注入. 注释3通过FindObjectOfType从IoC容器中找到类型和字段或属性类型相匹配的对象,查找会匹配类型.我们后面再细讲FindObjectOfType是如何实现的. 注释4将注释3找到的对象设置进字段,完成该字段注入. 注释5如果开启递归注入,则对该字段的值也进行注入. FindObjectOfType方法123456789101112131415161718192021public object FindObjectOfType(Type type){ /* 1-Start */ if (_FindCache.ContainsKey(type)) { return _FindCache[type]; } /* 1-End */ foreach (object instance in _Instances) { /* 2-Start */ if(type.IsAssignableFrom(instance.GetType())) { _FindCache.Add(type, instance); return instance; } /* 2-End */ } return null;} 注释1-Start到注释1-End中间的代码为从_FindCache中进行查找.如果之前已经通过该方法查到过该类型,那么该类型会进入_FindCache缓存,后续查找的时间复杂度就仅为O(1). 注释2-Start到注释2-End中间的代码为从已经实例化的_Instances中查找有没有能赋值给type类型的对象,如果有,则加入到_FindCache缓存并且返回结果.可以发现这里使用了Type.IsAssignableFrom进行类型匹配,因此如果你的字段使用了接口或某个父类,也能正常进行注入.接下来我们增加一个ILogManager接口测试一下. 将LogManager改为接口新增接口ILogManager12345678910111213public interface ILogManager{ public void Log(LogLevel level, string templte, params object[] args);}public enum LogLevel{ Debug, Info, Warning, Exception, Error} 新增ILogManager接口,并将LogManager中的枚举LogLevel删移动过来. 修改LogManager12345678910111213141516171819202122232425262728293031[IOCComponent]public class LogManager : ILogManager{ private LogLevel _LogLevel = LogLevel.Debug; public void Log(LogLevel level, string templte, params object[] args) { if (level &lt; _LogLevel) { return; } string msg = args == null || args.Length == 0 ? templte : string.Format(templte, args); msg = $&quot;[{level}] Frame={Time.frameCount} Time={Time.time} -- {msg}&quot;; switch (level) { case LogLevel.Debug: case LogLevel.Info: Debug.Log(msg); break; case LogLevel.Warning: Debug.LogWarning(msg); break; case LogLevel.Exception: Debug.LogException(new Exception(msg)); break; case LogLevel.Error: Debug.LogError(msg); break; } }} 让LogManager实现ILogManager接口 修改AssetManager的字段1234567891011121314151617181920212223242526[IOCComponent]public class AssetManager{ [Autowired] private CoroutineManager _CoroutineManager; [Autowired] /* 1 */ private ILogManager _LogManager; public void LoadAsync&lt;T&gt;(string assetPath, Action&lt;T&gt; onLoaded) where T : Object { _CoroutineManager.StartCoroutine(_LoadAsync(assetPath, onLoaded)); } private IEnumerator _LoadAsync&lt;T&gt;(string assetPath, Action&lt;T&gt; onLoaded) where T : Object { _LogManager.Log(LogLevel.Debug, &quot;Loading {0}&quot;, assetPath); // Your load code here // Now just wait for some seconds for demo yield return new WaitForSeconds(3); T loadedAsset = default(T); _LogManager.Log(LogLevel.Debug, &quot;Loaded {0} asset={1}&quot;, assetPath, loadedAsset); onLoaded?.Invoke(loadedAsset); }} 注释1可以看到之前字段_LogManager从LogManager类型修改为接口类型ILogManager. 同样地,将GameObjectManager中字段_LogManager从LogManager类型修改为接口类型ILogManager. 重新运行场景,发现结果和之前不使用接口是一样的. 如果你想指定所有需要管理的类怎么实现只需要去掉类定义上面的[IOCComponent],同时在构建IOCContainer时通过配置指定即可. 假设我们有如下的类1234567891011121314151617181920212223242526272829303132333435363738class You : IInstanceLifeCycle{ [Autowired] private Word _Word; [Autowired] [Qualifier(WORD_SPECIAL_INSTANCE)] private Word _Word2; public void Say() { Debug.LogError($&quot;Say {_Word.GetMsg()}&quot;); Debug.LogError($&quot;Say {_Word2.GetMsg()}&quot;); } public void BeforePropertiesOrFieldsSet() { } public void AfterPropertiesOrFieldsSet() { } public void AfterAllInstanceInit() { Say(); }}class Word{ private string _Msg = &quot;Hello&quot;; public string GetMsg() { return _Msg; }} 可以看到You中依赖了两个Word类型的实例.有一个Word通过Qualifier指定了具体实例. 接下来看如何构造IOCContainer. 通过配置构造IOCContainer123456789101112public class SpecifyByHand : MonoBehaviour{ public const string WORD_SPECIAL_INSTANCE = nameof(WORD_SPECIAL_INSTANCE); void Start() { IOCContainerConfiguration config = new IOCContainerConfiguration() .AddConfigInstanceInfo&lt;You&gt;() .AddConfigInstanceInfo&lt;Word&gt;() .AddConfigInstanceInfo&lt;Word&gt;(WORD_SPECIAL_INSTANCE, new ValueSetter(&quot;_Msg&quot;, &quot;Message&quot;)); new IOCContainerBuilder().SetConfiguration(config).Build(); }} 可以看到配置指定了创建两个Word实现和一个You,其中一个Word实例的Qualifier和上面You中字段上的Qualifier一致. 运行会输出: 12Say HelloSay Message 结束以上为了更容易讲明白IoC的实现原理,一步步实现了一个极简的IoC容器,实际上该容器还缺少很多特性,比如AOP、比如支持通过配置指定注入不同实例等.更完整的IoC框架已经在下面GITHUB中开发维护. 完整的Package工程地址在https://github.com/kakashiio/Unity-IOC 使用大家也可以通过PackageManager引用:打开Unity的PackageManager并点击左上角的“+”按钮,选择&quot;Add package from git URL...&quot;,加入如下两个地址 Package地址 说明 Git地址 https://github.com/kakashiio/Unity-Reflection.git#1.0.0 IOC依赖的反射库 https://github.com/kakashiio/Unity-Reflection https://github.com/kakashiio/Unity-IOC.git#1.0.0 IOC容器库 https://github.com/kakashiio/Unity-IOC 致谢感谢百忙之中阅读本文,如果觉得我的文章帮到了你,欢迎:转载、关注git、为仓库增加star等.你的简单回馈将是我继续创作的动力.","link":"/2022/05/03/Unity-IOC/"}],"tags":[{"name":"Unity3D","slug":"Unity3D","link":"/tags/Unity3D/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"代码设计","slug":"代码设计","link":"/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"},{"name":"架构","slug":"架构","link":"/tags/%E6%9E%B6%E6%9E%84/"},{"name":"Ioc","slug":"Ioc","link":"/tags/Ioc/"}],"categories":[{"name":"Unity3D","slug":"Unity3D","link":"/categories/Unity3D/"},{"name":"代码设计与架构","slug":"Unity3D/代码设计与架构","link":"/categories/Unity3D/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/"},{"name":"C#","slug":"C","link":"/categories/C/"},{"name":"代码设计与架构","slug":"C/代码设计与架构","link":"/categories/C/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84/"}]}